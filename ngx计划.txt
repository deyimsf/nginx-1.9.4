
注释空格替换
  core/ngx_conf_file.c/ 结束



1.纯文本值
  return 200 “I am value”;
 
  a.解析到return指令后,向lcf->codes中添加一个ngx_http_script_return_code_t脚本对象,该对象中有一个ngx_http_complex_value_t
    类型的text字段,该字段用来存放编译后的复杂值

  b.通过ngx_http_compile_complex_value()方法将复杂值编译到ngx_http_complex_value_t对象中,而该对象就是
    ngx_http_script_return_code_t->text字段的值

  c.因为是纯文本,所以编译后的ngx_http_complex_value_t对象,只有value有值,其它字段都为null



  a.获取动态值时,通过ngx_http_rewrite_handler()方法执行脚本之前放到lcf->codes中的脚本对象(ngx_http_script_return_code_t)
    
  b.执行脚本对象方法ngx_http_script_return_code(),该方法调用ngx_http_send_response()方法并传递ngx_http_complex_value_t
    对象参数(即ngx_http_script_return_code_t->text字段值)
  
  c.在ngx_http_send_response()方法中通过调用ngx_http_complex_value()方法来动态获取复杂值.
    该方法判断ngx_http_complex_value_t->lengths为NULL,则直接返回ngx_http_complex_value_t->value的字面值.
 

2.带变量的复杂值
  return 200 “I am $uri”;

  a.解析到return指令后,向lcf->codes中添加一个ngx_http_script_return_code_t脚本对象,该对象中有一个ngx_http_complex_value_t
    类型的text字段,该字段用来存放编译后的复杂值
  
  b.通过ngx_http_compile_complex_value()方法将复杂值编译到ngx_http_complex_value_t对象中,也就是
    ngx_http_script_return_code_t脚本对象的text字段

  c.TODO 看ngx_http_compile_complex_value()中处理复杂值中带变量的逻辑
        ngx_http_script_compile() 编译变量脚本
           ngx_http_script_add_var_code() 添加变量脚本  下周从这里看 TODO



  ngx_http_rewrite_return()  这里面用到了复杂值和脚本引擎

  ngx_http_compile_complex_value() 解析复杂值
  ngx_http_complex_value()  动态获取复杂值



rewrite阶段脚本引擎执行方法
  ngx_http_rewrite_handler()

然后看set如何解析变量












limit_req_zone $uri zone=cookie__jda:10m  rate=51r/s;

location / {

		limit_req zone=cookie__jda nodelay;
}

这个好像只对proxy_pass指令起作用啊。。。






/**************关于lua的****************/

/*创建一个新的lua状态机,以后所有的lua操作都依赖于该状态机(vm)*/
luaL_newstate();
/*打开指定状态机中的所有lua标准库*/
luaL_openlibs(L);
/*把居变量package里的值压栈,返回该值的类型*/
lua_getglobal(L, "package");


/*获取虚拟机(lua_State)*/
L = ngx_http_lua_get_lua_vm(r, NULL);

/*加载lua代码*/
ngx_http_lua_cache_loadbuffer
ngx_http_lua_cache_loadfile

/*运行lua代码*/
ngx_http_lua_run_thread




access_by_lua指令调用ngx.print()方法
  一但在该阶段调用ngx.print()方法后,该方法会把响应头也一块发出去,当在这个阶段把响应头发送出去后,
  由于ngx本身的框架限制,再执行后续的阶段是不安全的,因为后续阶段中的方法一般不会再自己的逻辑中判断
  响应头是否发送,还会按照原来的逻辑设置或修改响应头,这样整个逻辑就是错误的.

  ngx_lua模块在这个阶段中判断了这响应头是否发送的逻辑,当发送后会返会NGX_HTTP_OK(200),这样就不
  会执行后面的阶段了,就直接返回了.



ngx.location.capture(“/uri”)这个方法会阻塞后面的代码
  无论这个方法用在什么阶段,当这个方法没有返回的时候,ngx不会走后面的阶段,过滤器也不会走
  这种逻辑适用于ngx_lua中的所有阻塞方法,包括cosocket、ngx.print等








