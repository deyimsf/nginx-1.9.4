
注释空格替换
  core/ngx_conf_file.c/ 结束


TODO 看例子2
 
    看if指令解析? 
      ngx_http_rewrite_if()
        ngx_http_add_location()
        ngx_http_rewrite_if_condition()
  

    例子1:
      if ($uri) {}
        lcf->codes
          ngx_http_script_var_code_t
          ngx_http_script_if_code_t

    例子2:
       if ( $uri ) {}


    例子3：
       if ($uri ~* “I am $uri”){}
    

     

    


    看rewrite指令解析?
      ngx_http_rewrite
















———内置变量和自定义变量
  变量,既然是变量就需要先定义,未定义的变量在ngx是无法使用的,甚至连ngx都启动不起来,比如
       return 200 “$a”;
  像这样ngx是启动不起来的,需要先定义,比如
       set $a “I am a var”;
       return 200 “$a”;
  如此就是合法的

  看另一个例子
       return 200 “$uri”;
  ngx居然和毫发无伤的启动起来,在访问以下试试看
       curl http://127.0.0.1/uri
  打印
       /uri
  不是说没定义起不来吗,这个为啥不但起来了还可以肆无忌惮的输出值呢?
  原因是因为他是内置变量
  


———字符变量和二进制变量,以及其他可能的变量
  ngx中变量几乎都是字符串,既然是几乎那就有例外,看如下例子
     location / {
   
        return 200 “${binary_remote_addr}”;
     }
 
     location /a {

        return 200 “”;
     }
  分别访问两个url,看是什么结果
     curl http://127.0.0.1/
     curl http://127.0.0.1/a
  从视觉上看这两个都返回空字符,从返回值上似乎是没有任何差别的,似乎就可以推断出
  ${binary_remote_addr}变量是控制符,看ngx文档该变量是变量${remote_addr}
  的二进制形式,那既然${binary_remote_addr}是空字符,是不是代表以为我们访问的是
  本地ip地址${remote_addr}变量无法展示出本地ip呢,如果真是这样那么${remote_addr}
  变量也应该返回空字符,看如下例子
     location / {

         return 200 “${remote_addr}”;
     }
  访问该url
    curl http://127.0.0.1/
  结果打印如下
    127.0.0.1
  如此可以看到这个变量其实是有结果的,那么为什么${binary_remote_addr}就没有值呢
  
  继续看这个例子 
     location / {
   
        return 200 “${binary_remote_addr}”;
     }
  这次使用curl访问的时候带上-v参数,如下
     curl htpp://127.0.0.1 -v
  看结果如下
     < HTTP/1.1 200 OK
     < Server: nginx/1.9.4
     < Date: Fri, 06 Apr 2018 08:09:38 GMT
     < Content-Type: application/octet-stream
     < Content-Length: 4
     < Connection: keep-alive
  返回的响应头Content-Length字段值为4,这是个什么东西?
  这时候回过头再看ngx文档










/**************关于lua的****************/

/*创建一个新的lua状态机,以后所有的lua操作都依赖于该状态机(vm)*/
luaL_newstate();
/*打开指定状态机中的所有lua标准库*/
luaL_openlibs(L);
/*把居变量package里的值压栈,返回该值的类型*/
lua_getglobal(L, "package");


/*获取虚拟机(lua_State)*/
L = ngx_http_lua_get_lua_vm(r, NULL);

/*加载lua代码*/
ngx_http_lua_cache_loadbuffer
ngx_http_lua_cache_loadfile

/*运行lua代码*/
ngx_http_lua_run_thread




access_by_lua指令调用ngx.print()方法
  一但在该阶段调用ngx.print()方法后,该方法会把响应头也一块发出去,当在这个阶段把响应头发送出去后,
  由于ngx本身的框架限制,再执行后续的阶段是不安全的,因为后续阶段中的方法一般不会再自己的逻辑中判断
  响应头是否发送,还会按照原来的逻辑设置或修改响应头,这样整个逻辑就是错误的.

  ngx_lua模块在这个阶段中判断了这响应头是否发送的逻辑,当发送后会返会NGX_HTTP_OK(200),这样就不
  会执行后面的阶段了,就直接返回了.



ngx.location.capture(“/uri”)这个方法会阻塞后面的代码
  无论这个方法用在什么阶段,当这个方法没有返回的时候,ngx不会走后面的阶段,过滤器也不会走
  这种逻辑适用于ngx_lua中的所有阻塞方法,包括cosocket、ngx.print等








