

hash结构模糊查询 ?

TODO 明天,主要看通配符的支持,带*号为明天要看的重点

 ngx_http_server_names()方法中使用了
	ngx_hash_keys_array_init()方法初始化ngx_hash_keys_arrays_t结构体
	*ngx_hash_add_key()向ngx_hash_keys_arrays_t中添加键值对数据

        上面两个步骤费了那么大的力气只是为了准备数据

        然后调用下面的方法创建对应的hash结构
	1.用ngx_hash_init(ha.keys)方法创建不太通配符基本hash结构
        *2.用ngx_hash_wildcard_init(ha.dns_wc_head)方法创建存放前置通配符的hash结构体
        *3.用ngx_hash_wildcard_init(ha.dns_wc_tail)方法创建存放后置通配符的hash结构体


        *从前置通配符散列表中查找元素ngx_hash_find_wc_head()
        *从后置通配符散列表中查找元素ngx_hash_find_wc_tail()






















 共享内存 ?
 以后需要细看的
  http://nginx.org/en/docs/dev/development_guide.html#http_variables
  http://nginx.org/en/docs/dev/development_guide.html#http_complex_values
  变量脚本引擎

 

 



limit_req_zone $uri zone=cookie__jda:10m  rate=51r/s;

location / {

		limit_req zone=cookie__jda nodelay;
}

这个好像只对proxy_pass指令起作用啊。。。






/**************关于lua的****************/

/*创建一个新的lua状态机,以后所有的lua操作都依赖于该状态机(vm)*/
luaL_newstate();
/*打开指定状态机中的所有lua标准库*/
luaL_openlibs(L);
/*把居变量package里的值压栈,返回该值的类型*/
lua_getglobal(L, "package");


/*获取虚拟机(lua_State)*/
L = ngx_http_lua_get_lua_vm(r, NULL);

/*加载lua代码*/
ngx_http_lua_cache_loadbuffer
ngx_http_lua_cache_loadfile

/*运行lua代码*/
ngx_http_lua_run_thread




access_by_lua指令调用ngx.print()方法
  一但在该阶段调用ngx.print()方法后,该方法会把响应头也一块发出去,当在这个阶段把响应头发送出去后,
  由于ngx本身的框架限制,再执行后续的阶段是不安全的,因为后续阶段中的方法一般不会再自己的逻辑中判断
  响应头是否发送,还会按照原来的逻辑设置或修改响应头,这样整个逻辑就是错误的.

  ngx_lua模块在这个阶段中判断了这响应头是否发送的逻辑,当发送后会返会NGX_HTTP_OK(200),这样就不
  会执行后面的阶段了,就直接返回了.



ngx.location.capture(“/uri”)这个方法会阻塞后面的代码
  无论这个方法用在什么阶段,当这个方法没有返回的时候,ngx不会走后面的阶段,过滤器也不会走
  这种逻辑适用于ngx_lua中的所有阻塞方法,包括cosocket、ngx.print等













