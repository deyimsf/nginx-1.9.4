

hash结构模糊查询


ngx_http_optimize_servers
 ngx_http_server_names()  
    ngx_hash_wildcard_init()


 ngx_hash_wildcard_init()方法中关于前置通配符的逻辑基本了解
 比如了解了name->value中后两位掩码的作用
 但是产生了一个疑问,为什么区分01和00,感觉匹配的时候规则是一样的,只不过在配置文件的时候一个待星号一个不带

 TODO ngx_hash_wildcard_init()方法
   看为什么区分01和00
   看前置通配符的查找规则是不是和自己分析的一直
   看ngx_hash_wildcard_init()方法中关于后置通配符的规则
   看后置通配符的查找规则是不是和自己分析的一直

 





        /*
         * the 2 low bits of value have the special meaning:
         *     00 - value is data pointer for both "example.com"
         *          and "*.example.com";
         *     01 - value is data pointer for "*.example.com" only;
         *     10 - value is pointer to wildcard hash allowing
         *          both "example.com" and "*.example.com";
         *     11 - value is pointer to wildcard hash allowing
         *          "*.example.com" only.
         */


        /*
         * the 2 low bits of value have the special meaning:
         *     00 - value is data pointer;
         *     11 - value is pointer to wildcard hash allowing "example.*".
         */












 共享内存 ?
 以后需要细看的
  http://nginx.org/en/docs/dev/development_guide.html#http_variables
  http://nginx.org/en/docs/dev/development_guide.html#http_complex_values
  变量脚本引擎

 

 



limit_req_zone $uri zone=cookie__jda:10m  rate=51r/s;

location / {

		limit_req zone=cookie__jda nodelay;
}

这个好像只对proxy_pass指令起作用啊。。。






/**************关于lua的****************/

/*创建一个新的lua状态机,以后所有的lua操作都依赖于该状态机(vm)*/
luaL_newstate();
/*打开指定状态机中的所有lua标准库*/
luaL_openlibs(L);
/*把居变量package里的值压栈,返回该值的类型*/
lua_getglobal(L, "package");


/*获取虚拟机(lua_State)*/
L = ngx_http_lua_get_lua_vm(r, NULL);

/*加载lua代码*/
ngx_http_lua_cache_loadbuffer
ngx_http_lua_cache_loadfile

/*运行lua代码*/
ngx_http_lua_run_thread




access_by_lua指令调用ngx.print()方法
  一但在该阶段调用ngx.print()方法后,该方法会把响应头也一块发出去,当在这个阶段把响应头发送出去后,
  由于ngx本身的框架限制,再执行后续的阶段是不安全的,因为后续阶段中的方法一般不会再自己的逻辑中判断
  响应头是否发送,还会按照原来的逻辑设置或修改响应头,这样整个逻辑就是错误的.

  ngx_lua模块在这个阶段中判断了这响应头是否发送的逻辑,当发送后会返会NGX_HTTP_OK(200),这样就不
  会执行后面的阶段了,就直接返回了.



ngx.location.capture(“/uri”)这个方法会阻塞后面的代码
  无论这个方法用在什么阶段,当这个方法没有返回的时候,ngx不会走后面的阶段,过滤器也不会走
  这种逻辑适用于ngx_lua中的所有阻塞方法,包括cosocket、ngx.print等













