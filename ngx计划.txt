  
要debug看
   upstream tomcat {
	server 127.0.0.1:8080;
   }	

   location / {
	proxy_pass http://tomcat;
   }




upstream的配置信息看完了,明天看负载均衡相关的

TODO从下面方法开始看,如果自己要写一个负载均衡模块,应该设置哪些回调方法
  ngx_http_upstream_init_main_conf
	ngx_http_upstream_init_round_robin

  需要看ngx是如何选择upstream,以及如何选择upstream中的server的
  






看是如何均衡upstream下的server的?
 (http://nginx.org/en/docs/dev/development_guide.html#http_load_balancing)

看是什么情况下启动nextngx_http_upstream_next方法的?

ngx_url_t->naddrs 字段作用














 balance
 日志
 共享内存
 http请求过程



 以后需要细看的
  http://nginx.org/en/docs/dev/development_guide.html#http_variables
  http://nginx.org/en/docs/dev/development_guide.html#http_complex_values
  变量脚本引擎
 



limit_req_zone $uri zone=cookie__jda:10m  rate=51r/s;

location / {

		limit_req zone=cookie__jda nodelay;
}

这个好像只对proxy_pass指令起作用啊。。。






/**************关于lua的****************/

/*创建一个新的lua状态机,以后所有的lua操作都依赖于该状态机(vm)*/
luaL_newstate();
/*打开指定状态机中的所有lua标准库*/
luaL_openlibs(L);
/*把居变量package里的值压栈,返回该值的类型*/
lua_getglobal(L, "package");


/*获取虚拟机(lua_State)*/
L = ngx_http_lua_get_lua_vm(r, NULL);

/*加载lua代码*/
ngx_http_lua_cache_loadbuffer
ngx_http_lua_cache_loadfile

/*运行lua代码*/
ngx_http_lua_run_thread




access_by_lua指令调用ngx.print()方法
  一但在该阶段调用ngx.print()方法后,该方法会把响应头也一块发出去,当在这个阶段把响应头发送出去后,
  由于ngx本身的框架限制,再执行后续的阶段是不安全的,因为后续阶段中的方法一般不会再自己的逻辑中判断
  响应头是否发送,还会按照原来的逻辑设置或修改响应头,这样整个逻辑就是错误的.

  ngx_lua模块在这个阶段中判断了这响应头是否发送的逻辑,当发送后会返会NGX_HTTP_OK(200),这样就不
  会执行后面的阶段了,就直接返回了.



ngx.location.capture(“/uri”)这个方法会阻塞后面的代码
  无论这个方法用在什么阶段,当这个方法没有返回的时候,ngx不会走后面的阶段,过滤器也不会走
  这种逻辑适用于ngx_lua中的所有阻塞方法,包括cosocket、ngx.print等













